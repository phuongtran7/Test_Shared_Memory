// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_GINTAMA_H_
#define FLATBUFFERS_GENERATED_SCHEMA_GINTAMA_H_

#include "flatbuffers/flatbuffers.h"

namespace Gintama {

struct Character;
struct CharacterBuilder;

struct Yorozuya;
struct YorozuyaBuilder;

struct Character FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CharacterBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_QUOTE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *quote() const {
    return GetPointer<const flatbuffers::String *>(VT_QUOTE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_QUOTE) &&
           verifier.VerifyString(quote()) &&
           verifier.EndTable();
  }
};

struct CharacterBuilder {
  typedef Character Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Character::VT_NAME, name);
  }
  void add_quote(flatbuffers::Offset<flatbuffers::String> quote) {
    fbb_.AddOffset(Character::VT_QUOTE, quote);
  }
  explicit CharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CharacterBuilder &operator=(const CharacterBuilder &);
  flatbuffers::Offset<Character> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Character>(end);
    return o;
  }
};

inline flatbuffers::Offset<Character> CreateCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> quote = 0) {
  CharacterBuilder builder_(_fbb);
  builder_.add_quote(quote);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Character::Traits {
  using type = Character;
  static auto constexpr Create = CreateCharacter;
};

inline flatbuffers::Offset<Character> CreateCharacterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *quote = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto quote__ = quote ? _fbb.CreateString(quote) : 0;
  return Gintama::CreateCharacter(
      _fbb,
      name__,
      quote__);
}

struct Yorozuya FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef YorozuyaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_MEMBER = 6
  };
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Gintama::Character>> *member() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Gintama::Character>> *>(VT_MEMBER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyOffset(verifier, VT_MEMBER) &&
           verifier.VerifyVector(member()) &&
           verifier.VerifyVectorOfTables(member()) &&
           verifier.EndTable();
  }
};

struct YorozuyaBuilder {
  typedef Yorozuya Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(Yorozuya::VT_INDEX, index, 0);
  }
  void add_member(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Gintama::Character>>> member) {
    fbb_.AddOffset(Yorozuya::VT_MEMBER, member);
  }
  explicit YorozuyaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  YorozuyaBuilder &operator=(const YorozuyaBuilder &);
  flatbuffers::Offset<Yorozuya> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Yorozuya>(end);
    return o;
  }
};

inline flatbuffers::Offset<Yorozuya> CreateYorozuya(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Gintama::Character>>> member = 0) {
  YorozuyaBuilder builder_(_fbb);
  builder_.add_member(member);
  builder_.add_index(index);
  return builder_.Finish();
}

struct Yorozuya::Traits {
  using type = Yorozuya;
  static auto constexpr Create = CreateYorozuya;
};

inline flatbuffers::Offset<Yorozuya> CreateYorozuyaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0,
    const std::vector<flatbuffers::Offset<Gintama::Character>> *member = nullptr) {
  auto member__ = member ? _fbb.CreateVector<flatbuffers::Offset<Gintama::Character>>(*member) : 0;
  return Gintama::CreateYorozuya(
      _fbb,
      index,
      member__);
}

inline const Gintama::Yorozuya *GetYorozuya(const void *buf) {
  return flatbuffers::GetRoot<Gintama::Yorozuya>(buf);
}

inline const Gintama::Yorozuya *GetSizePrefixedYorozuya(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Gintama::Yorozuya>(buf);
}

inline bool VerifyYorozuyaBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Gintama::Yorozuya>(nullptr);
}

inline bool VerifySizePrefixedYorozuyaBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Gintama::Yorozuya>(nullptr);
}

inline void FinishYorozuyaBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Gintama::Yorozuya> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedYorozuyaBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Gintama::Yorozuya> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Gintama

#endif  // FLATBUFFERS_GENERATED_SCHEMA_GINTAMA_H_
